<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on hpeng526</title>
    <link>https://hpeng526.github.io/tags/java/</link>
    <description>Recent content in Java on hpeng526</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 19 Apr 2020 23:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://hpeng526.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>采坑笔记</title>
      <link>https://hpeng526.github.io/posts/20/2004-note/</link>
      <pubDate>Sun, 19 Apr 2020 23:00:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/20/2004-note/</guid>
      <description>笔记 RoekctMq 踩坑 同一个进程消费不同mq集群, 出现问题 // DefaultMQPushConsumerImpl.class public synchronized void start() throws MQClientException { switch (this.serviceState) { case CREATE_JUST: /** ignore */ this.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook); /** ignore */ } }// MQClientManager.class public MQClientInstance getAndCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook) { String clientId = clientConfig.buildMQClientId(); MQClientInstance instance = this.factoryTable.get(clientId); if (null == instance)</description>
    </item>
    
    <item>
      <title>async-profiler</title>
      <link>https://hpeng526.github.io/posts/20/2001-async-profiler/</link>
      <pubDate>Wed, 08 Jan 2020 23:00:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/20/2001-async-profiler/</guid>
      <description>async-profiler 一个低开销的, 不会有安全点偏差问题(Safepoint bias problem)的 Java 采样分析器. 它使用 HotSpot-specific APIs (AsyncGetCallTrace) 来收集堆栈和内存分配信息, perf_events 收集系统调</description>
    </item>
    
    <item>
      <title>G1GC 概念与性能调优 (jdk11)</title>
      <link>https://hpeng526.github.io/posts/19/1912-g1gc/</link>
      <pubDate>Tue, 24 Dec 2019 23:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/19/1912-g1gc/</guid>
      <description>G1GC 概念与性能调优 (jdk11) 本文不讨论 G1 底层数据结构与算法, 从 G1 GC 行为上做简要介绍 G1 的过程 Garbage-First Garbage Collector 从官网的描述来看 G1 is a generational, incremental, parallel, mostly concurrent, stop-the-world, and evacuating garbage collector which monitors pause-time goals in each</description>
    </item>
    
    <item>
      <title>RocketMQ 顺序消息</title>
      <link>https://hpeng526.github.io/posts/19/1911-rocketmq3/</link>
      <pubDate>Thu, 21 Nov 2019 23:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/19/1911-rocketmq3/</guid>
      <description>什么是顺序消息 (RocketMQ 4.5.1) RocketMq支持的消息类型 Simple Message Order Message (FIFO) Broadcasting Scheduled messages Batch Transaction messages RocketMq 提供FIFO的有序消息. 局部消息有序, 可以保证同一个消息消费队列中消</description>
    </item>
    
    <item>
      <title>RocketMQ 延迟消息</title>
      <link>https://hpeng526.github.io/posts/19/1908-rocketmq2/</link>
      <pubDate>Tue, 01 Oct 2019 14:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/19/1908-rocketmq2/</guid>
      <description>什么是延迟消息 (RocketMQ 4.5.1) RocketMq支持的消息类型 Simple Message Order Message (FIFO) Broadcasting Scheduled messages Batch Transaction messages 延迟消息跟普通消息的不一样之处就是, 他们不会立即发送, 而是等到给定时间</description>
    </item>
    
    <item>
      <title>RocketMQ 事务消息</title>
      <link>https://hpeng526.github.io/posts/19/1908-rocketmq/</link>
      <pubDate>Mon, 12 Aug 2019 22:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/19/1908-rocketmq/</guid>
      <description>什么是事务消息 (RocketMQ 4.5.1) RocketMQ 中, 可以把事务消息当成两阶段提交的消息, 用来确保分布式系统的最终一致性.事务消息确保可以以原子方式执行本地事务和消息发送</description>
    </item>
    
    <item>
      <title>记一次故障排查</title>
      <link>https://hpeng526.github.io/posts/19/1901-note/</link>
      <pubDate>Wed, 30 Jan 2019 22:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/19/1901-note/</guid>
      <description>记录一次生产问题排查 现象 生产一个导入导出服务频繁掉线，看监控指标发现GC频繁，应用内存快要达到上限。怀疑有业务代码有大内存问题，或者客户大</description>
    </item>
    
    <item>
      <title>Java CAS</title>
      <link>https://hpeng526.github.io/posts/18/1806cas/</link>
      <pubDate>Mon, 11 Jun 2018 23:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/18/1806cas/</guid>
      <description>CAS 是什么? 简单点讲, compare and swap (CAS) 是原子操作的一种, 可用于多线程编程中实现不被打断的数据交换操作, 解决数据不一致的问题. 大致的过程 &amp;gt; 假设内存有个数</description>
    </item>
    
    <item>
      <title>RocketMQ</title>
      <link>https://hpeng526.github.io/posts/17/1706rocketmq/</link>
      <pubDate>Fri, 02 Jun 2017 23:30:24 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/17/1706rocketmq/</guid>
      <description>自建 RocketMQ RocketMQ 阿里开源的一款高性能、高吞吐量的消息中间件. 现在为Apache 孵化器项目 支持消息类型 有序 普通无序(现在我们的订阅模式都是无序模式) 负</description>
    </item>
    
  </channel>
</rss>