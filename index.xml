<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hpeng526</title>
    <link>https://hpeng526.github.io/</link>
    <description>Recent content on hpeng526</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 10 Mar 2021 23:33:00 +0000</lastBuildDate>
    
	<atom:link href="https://hpeng526.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>golang 泛型预览</title>
      <link>https://hpeng526.github.io/posts/21/2103-go-generic/</link>
      <pubDate>Wed, 10 Mar 2021 23:33:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/21/2103-go-generic/</guid>
      <description>golang 泛型预览 终于，&amp;rdquo;大道至简&amp;rdquo;的go，泛型终于合并到master分支上去了。那么来了，让我们来搞一下 首先需要从源码编译</description>
    </item>
    
    <item>
      <title>采坑笔记</title>
      <link>https://hpeng526.github.io/posts/20/2004-note/</link>
      <pubDate>Sun, 19 Apr 2020 23:00:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/20/2004-note/</guid>
      <description>笔记 RoekctMq 踩坑 同一个进程消费不同mq集群, 出现问题 // DefaultMQPushConsumerImpl.class public synchronized void start() throws MQClientException { switch (this.serviceState) { case CREATE_JUST: /** ignore */ this.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook); /** ignore */ } }// MQClientManager.class public MQClientInstance getAndCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook) { String clientId = clientConfig.buildMQClientId(); MQClientInstance instance = this.factoryTable.get(clientId); if (null == instance)</description>
    </item>
    
    <item>
      <title>async-profiler</title>
      <link>https://hpeng526.github.io/posts/20/2001-async-profiler/</link>
      <pubDate>Wed, 08 Jan 2020 23:00:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/20/2001-async-profiler/</guid>
      <description>async-profiler 一个低开销的, 不会有安全点偏差问题(Safepoint bias problem)的 Java 采样分析器. 它使用 HotSpot-specific APIs (AsyncGetCallTrace) 来收集堆栈和内存分配信息, perf_events 收集系统调</description>
    </item>
    
    <item>
      <title>G1GC 概念与性能调优 (jdk11)</title>
      <link>https://hpeng526.github.io/posts/19/1912-g1gc/</link>
      <pubDate>Tue, 24 Dec 2019 23:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/19/1912-g1gc/</guid>
      <description>G1GC 概念与性能调优 (jdk11) 本文不讨论 G1 底层数据结构与算法, 从 G1 GC 行为上做简要介绍 G1 的过程 Garbage-First Garbage Collector 从官网的描述来看 G1 is a generational, incremental, parallel, mostly concurrent, stop-the-world, and evacuating garbage collector which monitors pause-time goals in each</description>
    </item>
    
    <item>
      <title>RocketMQ 顺序消息</title>
      <link>https://hpeng526.github.io/posts/19/1911-rocketmq3/</link>
      <pubDate>Thu, 21 Nov 2019 23:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/19/1911-rocketmq3/</guid>
      <description>什么是顺序消息 (RocketMQ 4.5.1) RocketMq支持的消息类型 Simple Message Order Message (FIFO) Broadcasting Scheduled messages Batch Transaction messages RocketMq 提供FIFO的有序消息. 局部消息有序, 可以保证同一个消息消费队列中消</description>
    </item>
    
    <item>
      <title>RocketMQ 延迟消息</title>
      <link>https://hpeng526.github.io/posts/19/1908-rocketmq2/</link>
      <pubDate>Tue, 01 Oct 2019 14:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/19/1908-rocketmq2/</guid>
      <description>什么是延迟消息 (RocketMQ 4.5.1) RocketMq支持的消息类型 Simple Message Order Message (FIFO) Broadcasting Scheduled messages Batch Transaction messages 延迟消息跟普通消息的不一样之处就是, 他们不会立即发送, 而是等到给定时间</description>
    </item>
    
    <item>
      <title>RocketMQ 事务消息</title>
      <link>https://hpeng526.github.io/posts/19/1908-rocketmq/</link>
      <pubDate>Mon, 12 Aug 2019 22:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/19/1908-rocketmq/</guid>
      <description>什么是事务消息 (RocketMQ 4.5.1) RocketMQ 中, 可以把事务消息当成两阶段提交的消息, 用来确保分布式系统的最终一致性.事务消息确保可以以原子方式执行本地事务和消息发送</description>
    </item>
    
    <item>
      <title>记一次故障排查</title>
      <link>https://hpeng526.github.io/posts/19/1901-note/</link>
      <pubDate>Wed, 30 Jan 2019 22:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/19/1901-note/</guid>
      <description>记录一次生产问题排查 现象 生产一个导入导出服务频繁掉线，看监控指标发现GC频繁，应用内存快要达到上限。怀疑有业务代码有大内存问题，或者客户大</description>
    </item>
    
    <item>
      <title>从 GC log 了解与分析 gc</title>
      <link>https://hpeng526.github.io/posts/18/1808cmsgc/</link>
      <pubDate>Mon, 06 Aug 2018 22:01:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/18/1808cmsgc/</guid>
      <description>CMS 介绍 CMS, Concurrent Mark Sweep, 并发的标记清楚算法GC. CMS 执行 初始化标记 并发标记 并发预清理 重标记 并发清理 重置 环境配置是 JDK8, HotSpot VM 应用配置的参数 -XX:+UseConcMarkSweepGC // 使用 CMS GC -XX:+UseCMSInitiatingOccupancyOnly // 不基</description>
    </item>
    
    <item>
      <title>Java CAS</title>
      <link>https://hpeng526.github.io/posts/18/1806cas/</link>
      <pubDate>Mon, 11 Jun 2018 23:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/18/1806cas/</guid>
      <description>CAS 是什么? 简单点讲, compare and swap (CAS) 是原子操作的一种, 可用于多线程编程中实现不被打断的数据交换操作, 解决数据不一致的问题. 大致的过程 &amp;gt; 假设内存有个数</description>
    </item>
    
    <item>
      <title>btrace 笔记</title>
      <link>https://hpeng526.github.io/posts/18/1804btrace/</link>
      <pubDate>Wed, 09 May 2018 23:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/18/1804btrace/</guid>
      <description>Btrace - a safe, dynamic tracing tool for the Java platform Btrace 加载过程 client Javac 加载 Btrace Verifier 编译成字节码 通过 attach 方法动态 attach 到 JVM Attach API submit 提交 Btrace 编译后的字节码到对应 PID VM.(socket 通信) try { Client client = new Client(port, OUTPUT_FILE, PROBE_DESC_PATH, DEBUG, TRACK_RETRANSFORM,</description>
    </item>
    
    <item>
      <title>travis-ci 部署 hexo</title>
      <link>https://hpeng526.github.io/posts/18/1801travis-hexo/</link>
      <pubDate>Thu, 18 Jan 2018 22:10:00 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/18/1801travis-hexo/</guid>
      <description>利用 travis-ci 自动生成 hexo 并提交，无非就几点要注意的，一个是 travis-ci 怎么有权限推送，另一个就是 travis-ci 怎么用。 从 .travis.yml 入手 下面是我的配置，很简单。 language: node_js node_js: stable install: - npm install script: -</description>
    </item>
    
    <item>
      <title>Docker生态使用与编排</title>
      <link>https://hpeng526.github.io/posts/17/1707docker%E7%94%9F%E6%80%81%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%BC%96%E6%8E%92/</link>
      <pubDate>Tue, 25 Jul 2017 23:18:47 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/17/1707docker%E7%94%9F%E6%80%81%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%BC%96%E6%8E%92/</guid>
      <description>Docker生态使用与编排 Docker 介绍 Docker 是一种容器技术，强依赖linux内核 容器（Container） 有时候也被称为操作系统级虚拟化，以区别传统的</description>
    </item>
    
    <item>
      <title>mbean信息采集系统</title>
      <link>https://hpeng526.github.io/posts/17/1707mbean%E4%BF%A1%E6%81%AF%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 25 Jul 2017 23:13:51 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/17/1707mbean%E4%BF%A1%E6%81%AF%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F/</guid>
      <description>mbean 信息采集系统 spring boot Actuator 这个不多讲，主要是利用 metrics 采集时间序列（time-series）数据，他也可以在 spring mvc 上使用，所以很容易在我们现有的系统上集</description>
    </item>
    
    <item>
      <title>ELK</title>
      <link>https://hpeng526.github.io/posts/17/1706elk/</link>
      <pubDate>Thu, 22 Jun 2017 23:21:22 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/17/1706elk/</guid>
      <description>ELK 搭建与使用 (5.4) ELK 是什么? ElasticSearch + logstash + kibana 是一套开源的日志管理检索方案 我采用的采集流程 +-----------+ | | | filebeat1 +------+ | | | +-------+ +-------------+ +-----------------+ +----------+ +-----------+ | | | | | | | | | +--&amp;gt; | redis +--&amp;gt; | logstash +---&amp;gt; |</description>
    </item>
    
    <item>
      <title>RocketMQ</title>
      <link>https://hpeng526.github.io/posts/17/1706rocketmq/</link>
      <pubDate>Fri, 02 Jun 2017 23:30:24 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/17/1706rocketmq/</guid>
      <description>自建 RocketMQ RocketMQ 阿里开源的一款高性能、高吞吐量的消息中间件. 现在为Apache 孵化器项目 支持消息类型 有序 普通无序(现在我们的订阅模式都是无序模式) 负</description>
    </item>
    
    <item>
      <title>利用Docker写Hexo文章</title>
      <link>https://hpeng526.github.io/posts/16/1611%E5%88%A9%E7%94%A8docker%E5%86%99hexo%E6%96%87%E7%AB%A0/</link>
      <pubDate>Tue, 08 Nov 2016 21:36:48 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/16/1611%E5%88%A9%E7%94%A8docker%E5%86%99hexo%E6%96%87%E7%AB%A0/</guid>
      <description>因为，每一次换环境都要重新弄 Hexo 的环境，才能愉快的写文（wu）章（liao）。于是乎，想到肯定有人把环境弄成 Docker 的，挂在目录就行了。这不，一搜就</description>
    </item>
    
    <item>
      <title>对编程的思考</title>
      <link>https://hpeng526.github.io/posts/16/1611%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Wed, 02 Nov 2016 21:34:56 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/16/1611%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>最近，新项目都上 Gitlab 了，对同事提交的代码进行 merge 到 master 的时候，发现不合我的规范，因此进行了一些讨论，引发了一些思考。 起因 项目是一个接入项目，我封装</description>
    </item>
    
    <item>
      <title>Docker 体验</title>
      <link>https://hpeng526.github.io/posts/16/1605docker-%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Sun, 29 May 2016 20:18:38 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/16/1605docker-%E4%BD%93%E9%AA%8C/</guid>
      <description>周末了，很早就想体验一下 Docker ，所以，就把很久以前用 Python + Flask 写的小项目用 Docker 部署一下。项目还用到了 Redis 所以，这次就简单的把所有东西揉在一个 Docker image 里好了。</description>
    </item>
    
    <item>
      <title>MyBatis 对象映射 （一）</title>
      <link>https://hpeng526.github.io/posts/16/1605mybatis-%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84-%E4%B8%80/</link>
      <pubDate>Thu, 26 May 2016 19:55:57 +0000</pubDate>
      
      <guid>https://hpeng526.github.io/posts/16/1605mybatis-%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84-%E4%B8%80/</guid>
      <description>Note: 尽量少用关联嵌套查询，因为关联嵌套查询会导致 N+1 查询问题，也就是说 如果你执行了一条SQL语句来获取结果列表(1) 对于返回的每一个查询语句，都</description>
    </item>
    
  </channel>
</rss>